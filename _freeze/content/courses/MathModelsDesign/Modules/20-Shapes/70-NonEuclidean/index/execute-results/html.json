{
  "hash": "4bab1e2ab6abf218b532a1d860657e7f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Non-Euclidean Geometry\"\nauthor: \"Arvind V.\"\ndate: 22/July/2024\ndate-modified: \" 2025-02-07 \"\norder: 70\nabstract: \"\"\ncitation: true\n---\n\n## Introduction\nTopics that may be covered here:\n\n- Hyperbolic Geometry\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# devtools::install_github(\"https://github.com/AdamRahman/sdpt3r\")\n# devtools::install_github(\"https://github.com/stla/PlaneGeometry\")\nlibrary(PlaneGeometry)\n```\n:::\n\n# Exeter point\n\nThe *Exeter point* is defined as follows on Wikipedia. \n\nLet $ABC$ be any given triangle. Let the medians through the vertices $A$, $B$, \n$C$ meet the circumcircle of triangle $ABC$ at $A'$, $B'$ and $C'$ respectively. \nLet $DEF$ be the triangle formed by the tangents at $A$, $B$, and $C$ to the \ncircumcircle of triangle $ABC$. (Let $D$ be the vertex opposite to the side \nformed by the tangent at the vertex $A$, let $E$ be the vertex opposite to the \nside formed by the tangent at the vertex $B$, and let $F$ be the vertex \nopposite to the side formed by the tangent at the vertex $C$.) \nThe lines through $DA'$, $EB'$ and $FC'$ are concurrent. \nThe point of concurrence is the Exeter point of triangle $ABC$.\n\nLet's construct it with the `PlaneGeometry` package. We do not need to \nconstruct the triangle $DEF$: it is the *tangential triangle* of $ABC$, and \nis provided by the `tangentialTriangle` method of the R6 class `Triangle`.\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- c(0, 2)\nB <- c(5, 4)\nC <- c(5, -1)\nt <- Triangle$new(A, B, C)\ncircumcircle <- t$circumcircle()\ncentroid <- t$centroid()\nmedianA <- Line$new(A, centroid)\nmedianB <- Line$new(B, centroid)\nmedianC <- Line$new(C, centroid)\nAprime <- intersectionCircleLine(circumcircle, medianA)[[2]]\nBprime <- intersectionCircleLine(circumcircle, medianB)[[2]]\nCprime <- intersectionCircleLine(circumcircle, medianC)[[1]]\nDEF <- t$tangentialTriangle()\nlineDAprime <- Line$new(DEF$A, Aprime)\nlineEBprime <- Line$new(DEF$B, Bprime)\nlineFCprime <- Line$new(DEF$C, Cprime)\n(ExeterPoint <- intersectionLineLine(lineDAprime, lineEBprime))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.621359 1.158114\n```\n\n\n:::\n\n```{.r .cell-code}\n# check whether the Exeter point is also on (FC')\nlineFCprime$includes(ExeterPoint)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\nLet's draw a figure now.\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(-2, 9), ylim = c(-6, 7),\n  xlab = NA, ylab = NA, axes = FALSE\n)\ndraw(t, lwd = 2, col = \"black\")\ndraw(circumcircle, lwd = 2, border = \"cyan\")\ndraw(Triangle$new(Aprime, Bprime, Cprime), lwd = 2, col = \"green\")\ndraw(DEF, lwd = 2, col = \"blue\")\ndraw(Line$new(ExeterPoint, DEF$A, FALSE, FALSE), lwd = 2, col = \"red\")\ndraw(Line$new(ExeterPoint, DEF$B, FALSE, FALSE), lwd = 2, col = \"red\")\ndraw(Line$new(ExeterPoint, DEF$C, FALSE, FALSE), lwd = 2, col = \"red\")\npoints(rbind(ExeterPoint), pch = 19, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Exeter-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\n\n# Circles tangent to three circles\n\nLet $\\mathcal{C}_1$, $\\mathcal{C}_2$ and $\\mathcal{C}_3$ be three circles with \nrespective radii $r_1$, $r_2$ and $r_3$ such that $r_3 < r_1$ and $r_3 < r_2$. \nHow to construct some circles simultaneously tangent to these three circles?\n\n::: {.cell}\n\n```{.r .cell-code}\nC1 <- Circle$new(c(0, 0), 2)\nC2 <- Circle$new(c(5, 5), 3)\nC3 <- Circle$new(c(6, -2), 1)\n# inversion swapping C1 and C3 with positive power\niota1 <- inversionSwappingTwoCircles(C1, C3, positive = TRUE)\n# inversion swapping C2 and C3 with positive power\niota2 <- inversionSwappingTwoCircles(C2, C3, positive = TRUE)\n# take an arbitrary point on C3\nM <- C3$pointFromAngle(0)\n# invert it with iota1 and iota2\nM1 <- iota1$invert(M)\nM2 <- iota2$invert(M)\n# take the circle C passing through M, M1, M2\nC <- Triangle$new(M, M1, M2)$circumcircle()\n# take the line passing through the two inversion poles\ncl <- Line$new(iota1$pole, iota2$pole)\n# take the radical axis of C and C3\nL <- C$radicalAxis(C3)\n# let H bet the intersection of these two lines\nH <- intersectionLineLine(L, cl)\n# take the circle Cp with diameter [HO3]\nO3 <- C3$center\nCp <- CircleAB(H, O3)\n# get the two intersection points T0 and T1 of C3 with Cp\nT0_and_T1 <- intersectionCircleCircle(C3, Cp)\nT0 <- T0_and_T1[[1L]]\nT1 <- T0_and_T1[[2L]]\n# invert T0 with respect to the two inversions\nT0p <- iota1$invert(T0)\nT0pp <- iota2$invert(T0)\n# the circle passing through T0 and its two images is a solution\nCsolution0 <- Triangle$new(T0, T0p, T0pp)$circumcircle()\n# invert T1 with respect to the two inversions\nT1p <- iota1$invert(T1)\nT1pp <- iota2$invert(T1)\n# the circle passing through T1 and its two images is another solution\nCsolution1 <- Triangle$new(T1, T1p, T1pp)$circumcircle()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(-4, 9), ylim = c(-4, 9),\n  xlab = NA, ylab = NA, axes = FALSE\n)\ndraw(C1, col = \"yellow\", border = \"red\")\ndraw(C2, col = \"yellow\", border = \"red\")\ndraw(C3, col = \"yellow\", border = \"red\")\ndraw(Csolution0, lwd = 2, border = \"blue\")\ndraw(Csolution1, lwd = 2, border = \"blue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tangentCircles-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\n\n# Apollonius circle of a triangle\n\nThere are several circles called \"Apollonius circle\". \nWe take the one defined as follows, with respect to a reference triangle:\n*the circle which touches all three excircles of the reference triangle \nand encompasses them*.\n\nIt can be constructed as the inversive image of the nine-point circle with \nrespect to the circle orthogonal to the excircles of the reference triangle. \nThis inversion can be obtained in `PlaneGeometry` with the function \n`inversionFixingThreeCircles`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# reference triangle\nt <- Triangle$new(c(0, 0), c(5, 3), c(3, -1))\n# nine-point circle\nnpc <- t$orthicTriangle()$circumcircle()\n# excircles\nexcircles <- t$excircles()\n# inversion with respect to the circle orthogonal to the excircles\niota <- inversionFixingThreeCircles(excircles$A, excircles$B, excircles$C)\n# Apollonius circle\nApolloniusCircle <- iota$invertCircle(npc)\n```\n:::\n\nLet's do a figure:\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(-10, 14), ylim = c(-5, 18),\n  xlab = NA, ylab = NA, axes = FALSE\n)\ndraw(t, lwd = 2)\ndraw(excircles$A, lwd = 2, border = \"blue\")\ndraw(excircles$B, lwd = 2, border = \"blue\")\ndraw(excircles$C, lwd = 2, border = \"blue\")\ndraw(ApolloniusCircle, lwd = 2, border = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/apollonius-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\nThe radius of the Apollonius circle is $\\frac{r^2+s^2}{4r}$ where $r$ is the \ninradius of the triangle and $s$ its semiperimeter. Let's check this point:\n\n::: {.cell}\n\n```{.r .cell-code}\ninradius <- t$inradius()\nsemiperimeter <- sum(t$edges()) / 2\n(inradius^2 + semiperimeter^2) / (4 * inradius)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11.15942\n```\n\n\n:::\n\n```{.r .cell-code}\nApolloniusCircle$radius\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11.15942\n```\n\n\n:::\n:::\n\n\n# Filling the lapping area of two circles\n\nLet two circles intersecting at two points. \nHow to fill the lapping area of the two circles?\n\n::: {.cell}\n\n```{.r .cell-code}\nO1 <- c(2, 5)\ncirc1 <- Circle$new(O1, 2)\nO2 <- c(4, 4)\ncirc2 <- Circle$new(O2, 3)\n\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL, asp = 1, xlim = c(0, 8), ylim = c(0, 8), xlab = NA, ylab = NA)\ndraw(circ1, border = \"purple\", lwd = 2)\ndraw(circ2, border = \"forestgreen\", lwd = 2)\n\nintersections <- intersectionCircleCircle(circ1, circ2)\nA <- intersections[[1]]\nB <- intersections[[2]]\npoints(rbind(A, B), pch = 19, col = c(\"red\", \"blue\"))\n\ntheta1 <- Arg((A - O1)[1] + 1i * (A - O1)[2])\ntheta2 <- Arg((B - O1)[1] + 1i * (B - O1)[2])\npath1 <- Arc$new(O1, circ1$radius, theta1, theta2, FALSE)$path()\n\ntheta1 <- Arg((A - O2)[1] + 1i * (A - O2)[2])\ntheta2 <- Arg((B - O2)[1] + 1i * (B - O2)[2])\npath2 <- Arc$new(O2, circ2$radius, theta2, theta1, FALSE)$path()\n\npolypath(rbind(path1, path2), col = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lappingArea-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\n\n# Hyperbolic tessellation \n\nIn the help page of the `Circle` R6 class (`?Circle`), we show how to draw \na hyperbolic triangle with the help of the method \n`orthogonalThroughTwoPointsOnCircle()`. Here we will use this method to \ndraw a hyperbolic tessellation.\n\n::: {.cell}\n\n```{.r .cell-code}\ntessellation <- function(depth, Thetas0, colors) {\n  stopifnot(\n    depth >= 3,\n    is.numeric(Thetas0),\n    length(Thetas0) == 3L,\n    is.character(colors),\n    length(colors) >= depth\n  )\n\n  circ <- Circle$new(c(0, 0), 3)\n\n  arcs <- lapply(seq_along(Thetas0), function(i) {\n    ip1 <- ifelse(i == length(Thetas0), 1L, i + 1L)\n    circ$orthogonalThroughTwoPointsOnCircle(Thetas0[i], Thetas0[ip1],\n      arc = TRUE\n    )\n  })\n  inversions <- lapply(arcs, function(arc) {\n    Inversion$new(arc$center, arc$radius^2)\n  })\n\n  Ms <- vector(\"list\", depth)\n\n  Ms[[1L]] <- lapply(Thetas0, function(theta) c(cos(theta), sin(theta)))\n\n  Ms[[2L]] <- vector(\"list\", 3L)\n  for (i in 1L:3L) {\n    im1 <- ifelse(i == 1L, 3L, i - 1L)\n    M <- inversions[[i]]$invert(Ms[[1L]][[im1]])\n    attr(M, \"iota\") <- i\n    Ms[[2L]][[i]] <- M\n  }\n\n  for (d in 3L:depth) {\n    n1 <- length(Ms[[d - 1L]])\n    n2 <- 2L * n1\n    Ms[[d]] <- vector(\"list\", n2)\n    k <- 0L\n    while (k < n2) {\n      for (j in 1L:n1) {\n        M <- Ms[[d - 1L]][[j]]\n        for (i in 1L:3L) {\n          if (i != attr(M, \"iota\")) {\n            k <- k + 1L\n            newM <- inversions[[i]]$invert(M)\n            attr(newM, \"iota\") <- i\n            Ms[[d]][[k]] <- newM\n          }\n        }\n      }\n    }\n  }\n\n  # plot ####\n  opar <- par(mar = c(0, 0, 0, 0), bg = \"black\")\n  plot(NULL,\n    asp = 1, xlim = c(-4, 4), ylim = c(-4, 4),\n    xlab = NA, ylab = NA, axes = FALSE\n  )\n  draw(circ, border = \"white\")\n  invisible(lapply(arcs, draw, col = colors[1L], lwd = 2))\n\n  Thetas <- lapply(\n    rapply(Ms, function(M) {\n      Arg(M[1L] + 1i * M[2L])\n    }, how = \"replace\"),\n    unlist\n  )\n\n  for (d in 2L:depth) {\n    thetas <- sort(unlist(Thetas[1L:d]))\n    for (i in 1L:length(thetas)) {\n      ip1 <- ifelse(i == length(thetas), 1L, i + 1L)\n      arc <- circ$orthogonalThroughTwoPointsOnCircle(thetas[i], thetas[ip1],\n        arc = TRUE\n      )\n      draw(arc, lwd = 2, col = colors[d])\n    }\n  }\n\n  par(opar)\n\n  invisible()\n}\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntessellation(\n  depth = 5L,\n  Thetas0 = c(0, 2, 3.8),\n  colors = viridisLite::viridis(5L)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tessellation-1.png){width=1200}\n:::\n:::\n\nHere is a version which allows to fill the hyperbolic triangles:\n\n::: {.cell}\n\n```{.r .cell-code}\ntessellation2 <- function(depth, Thetas0, colors) {\n  stopifnot(\n    depth >= 3,\n    is.numeric(Thetas0),\n    length(Thetas0) == 3L,\n    is.character(colors),\n    length(colors) - 1L >= depth\n  )\n\n  circ <- Circle$new(c(0, 0), 3)\n\n  arcs <- lapply(seq_along(Thetas0), function(i) {\n    ip1 <- ifelse(i == length(Thetas0), 1L, i + 1L)\n    circ$orthogonalThroughTwoPointsOnCircle(Thetas0[i], Thetas0[ip1],\n      arc = TRUE\n    )\n  })\n  inversions <- lapply(arcs, function(arc) {\n    Inversion$new(arc$center, arc$radius^2)\n  })\n\n  Ms <- vector(\"list\", depth)\n\n  Ms[[1L]] <- lapply(Thetas0, function(theta) c(cos(theta), sin(theta)))\n\n  Ms[[2L]] <- vector(\"list\", 3L)\n  for (i in 1L:3L) {\n    im1 <- ifelse(i == 1L, 3L, i - 1L)\n    M <- inversions[[i]]$invert(Ms[[1L]][[im1]])\n    attr(M, \"iota\") <- i\n    Ms[[2L]][[i]] <- M\n  }\n\n  for (d in 3L:depth) {\n    n1 <- length(Ms[[d - 1L]])\n    n2 <- 2L * n1\n    Ms[[d]] <- vector(\"list\", n2)\n    k <- 0L\n    while (k < n2) {\n      for (j in 1L:n1) {\n        M <- Ms[[d - 1L]][[j]]\n        for (i in 1L:3L) {\n          if (i != attr(M, \"iota\")) {\n            k <- k + 1L\n            newM <- inversions[[i]]$invert(M)\n            attr(newM, \"iota\") <- i\n            Ms[[d]][[k]] <- newM\n          }\n        }\n      }\n    }\n  }\n\n  # plot ####\n  opar <- par(mar = c(0, 0, 0, 0), bg = \"black\")\n  plot(NULL,\n    asp = 1, xlim = c(-4, 4), ylim = c(-4, 4),\n    xlab = NA, ylab = NA, axes = FALSE\n  )\n\n  path <- do.call(rbind, lapply(rev(arcs), function(arc) arc$path()))\n  polypath(path, col = colors[1L])\n\n  invisible(lapply(arcs, function(arc) {\n    path1 <- arc$path()\n    B <- arc$startingPoint()\n    A <- arc$endingPoint()\n    alpha1 <- Arg(A[1L] + 1i * A[2L])\n    alpha2 <- Arg(B[1L] + 1i * B[2L])\n    path2 <- Arc$new(c(0, 0), 3, alpha1, alpha2, FALSE)$path()\n    polypath(rbind(path1, path2), col = colors[2L])\n  }))\n\n  Thetas <- lapply(\n    rapply(Ms, function(M) {\n      Arg(M[1L] + 1i * M[2L])\n    }, how = \"replace\"),\n    unlist\n  )\n\n  for (d in 2L:depth) {\n    thetas <- sort(unlist(Thetas[1L:d]))\n    for (i in 1L:length(thetas)) {\n      ip1 <- ifelse(i == length(thetas), 1L, i + 1L)\n      arc <- circ$orthogonalThroughTwoPointsOnCircle(thetas[i], thetas[ip1],\n        arc = TRUE\n      )\n      path1 <- arc$path()\n      B <- arc$startingPoint()\n      A <- arc$endingPoint()\n      alpha1 <- Arg(A[1L] + 1i * A[2L])\n      alpha2 <- Arg(B[1L] + 1i * B[2L])\n      path2 <- Arc$new(c(0, 0), 3, alpha1, alpha2, FALSE)$path()\n      polypath(rbind(path1, path2), col = colors[d + 1L])\n    }\n  }\n\n  draw(circ, border = \"white\")\n\n  par(opar)\n\n  invisible()\n}\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntessellation2(\n  depth = 5L,\n  Thetas0 = c(0, 2, 3.8),\n  colors = viridisLite::viridis(6L)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/tessellation2-1.png){width=1200}\n:::\n:::\n\n\n# Director circle of an ellipse \n\nLet's draw the [director circle](https://en.wikipedia.org/wiki/Director_circle) \nof an ellipse. We start by constructing the minimum bounding box of the ellipse.\n\n::: {.cell}\n\n```{.r .cell-code}\nell <- Ellipse$new(c(1, 1), 5, 2, 30)\nmajorAxis <- ell$diameter(0)\nminorAxis <- ell$diameter(pi / 2)\nv1 <- (majorAxis$B - majorAxis$A) / 2\nv2 <- (minorAxis$B - minorAxis$A) / 2\n# sides of the minimum bounding box\nside1 <- majorAxis$translate(v2)\nside2 <- majorAxis$translate(-v2)\nside3 <- minorAxis$translate(v1)\nside4 <- minorAxis$translate(-v1)\n# take a vertex of the bounding box\nA <- side1$A\n# director circle\ncirc <- CircleOA(ell$center, A)\n```\n:::\n\nNow let's take a tangent $T_1$ to the ellipse, construct the half-line \ndirected by $T_1$ with origin the point of tangency, determine the intersection \npoint of this half-line with the director circle, and draw the perpendicular \n$T_2$ of $T_1$ passing by this intersection point. \nThen $T_2$ is another tangent to the ellipse.\n\n::: {.cell}\n\n```{.r .cell-code}\nT1 <- ell$tangent(0.3)\nhalfT1 <- T1$clone(deep = TRUE)\nhalfT1$extendA <- FALSE\nI <- intersectionCircleLine(circ, halfT1, strict = TRUE)\nT2 <- T1$perpendicular(I)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1,\n  xlim = c(-3, 6), ylim = c(-5, 7), xlab = NA, ylab = NA\n)\n# draw the ellipse\ndraw(ell, col = \"blue\")\n# draw the bounding box\ndraw(side1, lwd = 2, col = \"green\")\ndraw(side2, lwd = 2, col = \"green\")\ndraw(side3, lwd = 2, col = \"green\")\ndraw(side4, lwd = 2, col = \"green\")\n# draw the director circle\ndraw(circ, lwd = 2, border = \"red\")\n# draw the two tangents\ndraw(T1)\ndraw(T2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/directorCircle-1.png){width=1200}\n:::\n\n```{.r .cell-code}\n# restore the graphical parameters\npar(opar)\n```\n:::\n\n\n# Playing with Steiner chains\n\nThe `PlaneGeometry` package has a function `SteinerChain` which generates \na Steiner chain of circles.\n\n## Elliptical Steiner chain\n\nBy applying an affine transformation to a Steiner chain, we can get an \nelliptical Steiner chain.\n\n::: {.cell}\n\n```{.r .cell-code}\nc0 <- Circle$new(c(3, 0), 3) # exterior circle\ncircles <- SteinerChain(c0, 3, -0.2, 0.5)\n# take an ellipse\nell <- Ellipse$new(c(-4, 0), 4, 2.5, 140)\n# take the affine transformation which maps the exterior circle to this ellipse\nf <- AffineMappingEllipse2Ellipse(c0, ell)\n# take the images of the Steiner circles by this transformation\nellipses <- lapply(circles, f$transformEllipse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(-8, 6), ylim = c(-4, 4),\n  xlab = NA, ylab = NA, axes = FALSE\n)\n# draw the Steiner chain\ninvisible(lapply(circles, draw, lwd = 2, col = \"blue\"))\ndraw(c0, lwd = 2)\n# draw the elliptical Steiner chain\ninvisible(lapply(ellipses, draw, lwd = 2, col = \"red\", border = \"forestgreen\"))\ndraw(ell, lwd = 2, border = \"forestgreen\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ellipticalSteiner-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\nHere is how I got the animation below, by varying the `shift` parameter of \nthe Steiner chain.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gifski)\n\nc0 <- Circle$new(c(3, 0), 3)\nell <- Ellipse$new(c(-4, 0), 4, 2.5, 140)\nf <- AffineMappingEllipse2Ellipse(c0, ell)\n\nfplot <- function(shift) {\n  circles <- SteinerChain(c0, 3, -0.2, shift)\n  ellipses <- lapply(circles, f$transformEllipse)\n  opar <- par(mar = c(0, 0, 0, 0))\n  plot(NULL,\n    asp = 1, xlim = c(-8, 0), ylim = c(-4, 4),\n    xlab = NA, ylab = NA, axes = FALSE\n  )\n  invisible(lapply(ellipses, draw, lwd = 2, col = \"blue\", border = \"black\"))\n  draw(ell, lwd = 2)\n  par(opar)\n  invisible()\n}\n\nshift_ <- seq(0, 3, length.out = 100)[-1L]\n\nsave_gif(\n  for (shift in shift_) {\n    fplot(shift)\n  },\n  \"SteinerChainElliptical.gif\",\n  512, 512, 1 / 12,\n  res = 144\n)\n```\n:::\n\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/SteinerChainElliptical.gif){width=60%}\n\n## Nested Steiner chains\n\nWe can choose the exterior circle of the Steiner chain. Therefore, given a \ncircle of a Steiner chain, we can nest another Steiner chain in this circle.\n\n::: {.cell}\n\n```{.r .cell-code}\nc0 <- Circle$new(c(3, 0), 3) # exterior circle\ncircles <- SteinerChain(c0, 3, -0.2, 0.5)\n# Steiner chain for each circle, except the small one (it is too small)\nchains <- lapply(circles[1:3], function(c0) {\n  SteinerChain(c0, 3, -0.2, 0.5)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(0, 6), ylim = c(-4, 4),\n  xlab = NA, ylab = NA, axes = FALSE\n)\n# draw the big Steiner chain\ninvisible(lapply(circles, draw, lwd = 2, border = \"blue\"))\ndraw(c0, lwd = 2)\n# draw the nested Steiner chain\ninvisible(lapply(chains, function(circles) {\n  lapply(circles, draw, lwd = 2, border = \"red\")\n}))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/nestedSteiner-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\nOf course you can also nest elliptical Steiner chains, and animate the \npicture!\n\n\n# Elliptical billiard\n\nThe following code plots the trajectory of a ball on an elliptical billiard.\n\n::: {.cell}\n\n```{.r .cell-code}\nreflect <- function(incidentDir, normalVec) {\n  incidentDir - 2 * c(crossprod(normalVec, incidentDir)) * normalVec\n}\n\n# n: number of segments; P0: initial point; v0: initial direction\ntrajectory <- function(n, P0, v0) {\n  out <- vector(\"list\", n)\n  L <- Line$new(P0, P0 + v0)\n  inters <- intersectionEllipseLine(ell, L)\n  Q0 <- inters$I2\n  out[[1]] <- Line$new(inters$I1, inters$I2, FALSE, FALSE)\n  for (i in 2:n) {\n    theta <- atan2(Q0[2], Q0[1])\n    t <- ell$theta2t(theta, degrees = FALSE)\n    nrmlVec <- ell$normal(t)\n    v <- reflect(Q0 - P0, nrmlVec)\n    inters <- intersectionEllipseLine(ell, Line$new(Q0, Q0 + v))\n    out[[i]] <- Line$new(inters$I1, inters$I2, FALSE, FALSE)\n    P0 <- Q0\n    Q0 <- if (isTRUE(all.equal(Q0, inters$I1))) inters$I2 else inters$I1\n  }\n  out\n}\n\nell <- Ellipse$new(c(0, 0), 6, 3, 0)\n\nP0 <- ell$pointFromAngle(60)\nv0 <- c(cos(pi + 0.8), sin(pi + 0.8))\ntraj <- trajectory(150, P0, v0)\n\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(-7, 7), ylim = c(-4, 4),\n  xlab = NA, ylab = NA, axes = FALSE\n)\ndraw(ell, border = \"red\", col = \"springgreen\", lwd = 3)\ninvisible(lapply(traj, draw))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/billiard-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\nRun the code below to see an animated trajectory:\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  asp = 1, xlim = c(-7, 7), ylim = c(-4, 4),\n  xlab = NA, ylab = NA, axes = FALSE\n)\ndraw(ell, border = \"red\", col = \"springgreen\", lwd = 3)\nfor (i in 1:length(traj)) {\n  draw(traj[[i]])\n  Sys.sleep(0.3)\n}\npar(opar)\n```\n:::\n\n\n# An illustration of inversions\n\nA *generalized circle* is either a circle or a line. The following code \ngenerates a family of generalized circles by repeatedly applying inversions:\n\n::: {.cell}\n\n```{.r .cell-code}\n# generation 0\nangles <- c(0, pi / 2, pi, 3 * pi / 2)\nbigCircle <- Circle$new(center = c(0, 0), radius = 2)\nattr(bigCircle, \"gen\") <- 0L\nattr(bigCircle, \"base\") <- length(angles) + 1L\ngen0 <- c(\n  lapply(seq_along(angles), function(i) {\n    beta <- angles[i]\n    circle <- Circle$new(center = c(cos(beta), sin(beta)), radius = 1)\n    attr(circle, \"gen\") <- 0L\n    attr(circle, \"base\") <- i\n    circle\n  }),\n  list(\n    bigCircle\n  )\n)\nn0 <- length(gen0)\n\n# generations 1, 2, 3\ngenerations <- vector(\"list\", length = 4L)\ngenerations[[1L]] <- gen0\nfor (g in 2L:4L) {\n  gen <- generations[[g - 1L]]\n  n <- length(gen)\n  n1 <- n * (n0 - 1L)\n  gen_new <- vector(\"list\", length = n1)\n  k <- 0L\n  while (k < n1) {\n    for (j in 1L:n) {\n      gcircle_j <- gen[[j]]\n      base <- attr(gcircle_j, \"base\")\n      for (i in 1L:n0) {\n        if (i != base) {\n          k <- k + 1L\n          circ <- gen0[[i]]\n          iota <- Inversion$new(pole = circ$center, power = circ$radius^2)\n          gcircle <- iota$invertGcircle(gcircle_j)\n          attr(gcircle, \"gen\") <- g - 1L\n          attr(gcircle, \"base\") <- i\n          gen_new[[k]] <- gcircle\n        }\n      }\n    }\n  }\n  generations[[g]] <- gen_new\n}\n\ngcircles <- c(\n  generations[[1L]], generations[[2L]], generations[[3L]], generations[[4L]]\n)\n```\n:::\n\nThere are 425 generalized circles:\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(gcircles)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 425\n```\n\n\n:::\n:::\n\nBut some of them are duplicated. In order to remove the duplicates, I will use \nthe following function `uniqueWith`, which takes as arguments a list or a \nvector and a function representing a binary relation between the elements of \nthis collection:\n\n::: {.cell}\n\n```{.r .cell-code}\nuniqueWith <- function(v, f) {\n  size <- length(v)\n  for (i in seq_len(size - 1L)) {\n    j <- i + 1L\n    while (j <= size) {\n      if (f(v[[i]], v[[j]])) {\n        v <- v[-j]\n        size <- size - 1L\n      } else {\n        j <- j + 1L\n      }\n    }\n  }\n  v[1L:size]\n}\n```\n:::\n\nFor example:\n\n::: {.cell}\n\n```{.r .cell-code}\nuniqueWith(\n  c(a = \"you\", b = \"are\", c = \"great\"),\n  function(x, y) nchar(x) == nchar(y)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      a       c \n  \"you\" \"great\" \n```\n\n\n:::\n:::\n\nSo we can remove the duplicated generalized circles as follows:\n\n::: {.cell}\n\n```{.r .cell-code}\ngcircles <- uniqueWith(\n  gcircles,\n  function(g1, g2) {\n    class(g1)[1L] == class(g2)[1L] && g1$isEqual(g2)\n  }\n)\n```\n:::\n\nNow it remains 161 generalized circles:\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(gcircles)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 158\n```\n\n\n:::\n:::\n\nLet's write a helper function to draw these generalized circles:\n\n::: {.cell}\n\n```{.r .cell-code}\ndrawGcircle <- function(gcircle, colors = rainbow(4L), ...) {\n  gen <- attr(gcircle, \"gen\")\n  if (is(gcircle, \"Circle\")) {\n    draw(gcircle, border = colors[1L + gen], ...)\n  } else {\n    draw(gcircle, col = colors[1L + gen], ...)\n  }\n}\n```\n:::\n\nAnd now let's draw them:\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0), bg = \"black\")\nplot(0, 0,\n  type = \"n\", xlim = c(-2.3, 2.3), ylim = c(-2.3, 2.3),\n  asp = 1, axes = FALSE, xlab = NA, ylab = NA\n)\ninvisible(lapply(gcircles, drawGcircle, lwd = 2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/draw_gcircles-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\n\n# Schottky circles\n\nThis construction is taken from the book *Indra's Pearls: The Vision of Felix Klein*.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(freegroup)\n\na <- alpha(1)\nA <- inverse(a)\nb <- alpha(2)\nB <- inverse(b)\n\n# words of size n\nn <- 6L\nG <- do.call(expand.grid, rep(list(c(\"a\", \"A\", \"b\", \"B\")), n))\nG <- split(as.matrix(G), 1:nrow(G))\nG <- lapply(G, function(w) {\n  sum(do.call(c.free, lapply(w, function(x) {\n    switch(x,\n      a = a,\n      A = A,\n      b = b,\n      B = B\n    )\n  })))\n})\nG <- uniqueWith(G, free_equal)\nsizes <- vapply(G, total, numeric(1L))\nGn <- G[sizes == n]\n\n# starting circles ####\nCa <- Line$new(c(-1, 0), c(1, 0))\nRc <- sqrt(2) / 4\nyI <- -3 * sqrt(2) / 4\nCA <- Circle$new(c(0, yI), Rc)\ntheta <- -0.5\nT <- c(Rc * cos(theta), yI + Rc * sin(theta))\nP <- c(T[1] + T[2] * tan(theta), 0)\nPT <- sqrt(c(crossprod(T - P)))\nxTprime <- P[1] + PT\nxPprime <- -yI / tan(theta)\nPprimeTprime <- abs(xTprime - xPprime)\nRcprime <- abs(yI * PprimeTprime / xPprime)\nCb <- Circle$new(c(xTprime, -Rcprime), Rcprime)\nCB <- Circle$new(c(-xTprime, -Rcprime), Rcprime)\nGCIRCLES <- list(a = Ca, A = CA, b = Cb, B = CB)\n\n# Mobius transformations ####\nMob_a <- Mobius$new(rbind(c(sqrt(2), 1i), c(-1i, sqrt(2))))\nMob_A <- Mob_a$inverse()\n\ntoCplx <- function(xy) complex(real = xy[1], imaginary = xy[2])\nMob_b <- Mobius$new(rbind(\n  c(toCplx(Cb$center), c(crossprod(Cb$center)) - Cb$radius^2),\n  c(1, -toCplx(CB$center))\n))\nMob_B <- Mob_b$inverse()\n\nMOBS <- list(a = Mob_a, A = Mob_A, b = Mob_b, B = Mob_B)\n\n# Conversion word of size n to circle\nword2seq <- function(g) {\n  seq <- c()\n  gr <- reduce(g)[[1L]]\n  for (j in 1L:ncol(gr)) {\n    monomial <- gr[, j]\n    t <- c(\"a\", \"b\")[monomial[1L]]\n    i <- monomial[2L]\n    if (i < 0L) {\n      i <- -i\n      t <- toupper(t)\n    }\n    seq <- c(seq, rep(t, i))\n  }\n  seq\n}\nword2circle <- function(g) {\n  seq <- word2seq(g)\n  mobs <- MOBS[seq]\n  mobius <- Reduce(function(M1, M2) M1$compose(M2), mobs[-n])\n  mobius$transformGcircle(GCIRCLES[[seq[n]]])\n}\n```\n:::\n\nHere is the picture:\n\n::: {.cell}\n\n```{.r .cell-code}\nopar <- par(mar = c(0, 0, 0, 0), bg = \"black\")\nplot(NULL,\n  asp = 1, xlim = c(-3, 3), ylim = c(-3, 3),\n  axes = FALSE, xlab = NA, ylab = NA\n)\ndraw(Ca)\ndraw(CA)\ndraw(Cb)\ndraw(CB)\nC1 <- Mob_A$transformCircle(CA)\nC2 <- Mob_A$transformCircle(CB)\nC3 <- Mob_A$transformCircle(Cb)\ndraw(C1, lwd = 2, border = \"red\")\ndraw(C2, lwd = 2, border = \"red\")\ndraw(C3, lwd = 2, border = \"red\")\nC1 <- Mob_a$transformLine(Ca)\nC2 <- Mob_a$transformCircle(Cb)\nC3 <- Mob_a$transformCircle(CB)\ndraw(C1, lwd = 2, border = \"green\")\ndraw(C2, lwd = 2, border = \"green\")\ndraw(C3, lwd = 2, border = \"green\")\nC1 <- Mob_b$transformLine(Ca)\nC2 <- Mob_b$transformCircle(CA)\nC3 <- Mob_b$transformCircle(Cb)\ndraw(C1, lwd = 2, border = \"blue\")\ndraw(C2, lwd = 2, border = \"blue\")\ndraw(C3, lwd = 2, border = \"blue\")\nC1 <- Mob_B$transformLine(Ca)\nC2 <- Mob_B$transformCircle(CA)\nC3 <- Mob_B$transformCircle(CB)\ndraw(C1, lwd = 2, border = \"yellow\")\ndraw(C2, lwd = 2, border = \"yellow\")\ndraw(C3, lwd = 2, border = \"yellow\")\nfor (g in Gn) {\n  circ <- word2circle(g)\n  draw(circ, lwd = 2, border = \"orange\")\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/draw_schottky-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\nHere is the same picture but with better quality:\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/SchottkyCircles_tikz.png){width=60%}\n\nI realized this picture with the **tikzDevice** package.\n\n\n# Modular tesselation\n\nI did this animation after I came across the paper \n[Complex Variables Visualized](https://www3.risc.jku.at/publications/download/risc_5011/DiplomaThesisPonweiser.pdf) written by Thomas Ponweiser. This is the paper \nwhich motivated me to implement the generalized power of a Möbius transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(elliptic) # for the unimodular matrices\n\n# Möbius transformations\nT <- Mobius$new(rbind(c(0, -1), c(1, 0)))\nU <- Mobius$new(rbind(c(1, 1), c(0, 1)))\nR <- U$compose(T)\n# R**t, generalized power\nRt <- function(t) {\n  R$gpower(t)\n}\n\n# starting circles\nI <- Circle$new(c(0, 1.5), 0.5)\nTI <- T$transformCircle(I)\n\n# modified Cayley transformation\nPhi <- Mobius$new(rbind(c(1i, 1), c(1, 1i)))\n\n\ndraw_pair <- function(M, u, compose = FALSE) {\n  if (compose) M <- M$compose(T)\n  A <- M$compose(Rt(u))$compose(Phi)\n  C <- A$transformCircle(I)\n  draw(C, col = \"magenta\")\n  C <- A$transformCircle(TI)\n  draw(C, col = \"magenta\")\n  if (!compose) {\n    draw_pair(M, u, compose = TRUE)\n  }\n}\n\nn <- 8L\ntransfos <- unimodular(n)\n\nfplot <- function(u) {\n  opar <- par(mar = c(0, 0, 0, 0), bg = \"black\")\n  plot(NULL,\n    asp = 1, xlim = c(-1.1, 1.1), ylim = c(-1.1, 1.1),\n    axes = FALSE, xlab = NA, ylab = NA\n  )\n  for (i in 1L:dim(transfos)[3L]) {\n    transfo <- transfos[, , i]\n    M <- Mobius$new(transfo)\n    draw_pair(M, u)\n    M <- M$inverse()\n    draw_pair(M, u)\n    diag(transfo) <- -diag(transfo)\n    M <- Mobius$new(transfo)\n    draw_pair(M, u)\n    M <- M$inverse()\n    draw_pair(M, u)\n    d <- diag(transfo)\n    if (d[1L] != d[2L]) {\n      diag(transfo) <- rev(diag(transfo))\n      M <- Mobius$new(transfo)\n      draw_pair(M, u)\n      M <- M$inverse()\n      draw_pair(M, u)\n    }\n  }\n}\n```\n:::\n\nTo get the animation, run:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gifski)\nu_ <- seq(0, 3, length.out = 181)[-1]\nsave_gif(\n  for (u in u_) {\n    fplot(u)\n  },\n  width = 512,\n  height = 512,\n  delay = 0.1\n)\n```\n:::\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/modularTessellation_compressed.gif){width=60%}\n\n\n# Apollonian gasket\n\nIt is not hard to draw an Apollonian gasket with `PlaneGeometry`. We do a \nfunction, in order to use it later to do an animation.\n\n::: {.cell}\n\n```{.r .cell-code}\n# function to construct the \"children\" ####\nApollonianChildren <- function(inversions, circles1) {\n  m <- length(inversions)\n  n <- length(circles1)\n  circles2 <- list()\n  for (i in 1:n) {\n    circ <- circles1[[i]]\n    k <- attr(circ, \"inversion\")\n    for (j in 1:m) {\n      if (j != k) {\n        circle <- inversions[[j]]$invertCircle(circ)\n        attr(circle, \"inversion\") <- j\n        circles2 <- append(circles2, circle)\n      }\n    }\n  }\n  circles2\n}\n\nApollonianGasket <- function(c0, n, phi, shift, depth) {\n  circles0 <- SteinerChain(c0, n, phi, shift)\n  # construct the inversions ####\n  inversions <- vector(\"list\", n + 1)\n  for (i in 1:n) {\n    inversions[[i]] <- inversionFixingThreeCircles(\n      c0, circles0[[i]], circles0[[(i %% n) + 1]]\n    )\n  }\n  inversions[[n + 1]] <- inversionSwappingTwoCircles(c0, circles0[[n + 1]])\n  # first generation of children\n  circles1 <- list()\n  for (i in 1:n) {\n    ip1 <- (i %% n) + 1\n    for (j in 1:(n + 1)) {\n      if (j != i && j != ip1) {\n        circle <- inversions[[i]]$invertCircle(circles0[[j]])\n        attr(circle, \"inversion\") <- i\n        circles1 <- append(circles1, circle)\n      }\n    }\n  }\n  # construct children ####\n  allCircles <- vector(\"list\", depth)\n  allCircles[[1]] <- circles0\n  allCircles[[2]] <- circles1\n  for (i in 3:depth) {\n    allCircles[[i]] <- ApollonianChildren(inversions, allCircles[[i - 1]])\n  }\n  allCircles\n}\n```\n:::\n\nLet's apply our function:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(viridisLite) # for the colors\nc0 <- Circle$new(c(0, 0), 3) # the exterior circle\ndepth <- 5\ncolors <- plasma(depth)\nApollonianCircles <- ApollonianGasket(c0, n = 3, phi = 0.3, shift = 0, depth)\n# plot ####\ncenter0 <- c0$center\nradius0 <- c0$radius\nxlim <- center0[1] + c(-radius0 - 0.1, radius0 + 0.1)\nylim <- center0[2] + c(-radius0 - 0.1, radius0 + 0.1)\nopar <- par(mar = c(0, 0, 0, 0))\nplot(NULL,\n  type = \"n\", xlim = xlim, ylim = ylim,\n  xlab = NA, ylab = NA, axes = FALSE, asp = 1\n)\ndraw(c0, border = \"black\", lwd = 2)\nfor (i in 1:depth) {\n  for (circ in ApollonianCircles[[i]]) {\n    draw(circ, col = colors[i])\n  }\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/drawgasket-1.png){width=1200}\n:::\n\n```{.r .cell-code}\npar(opar)\n```\n:::\n\nWe can do an animation now:\n\n::: {.cell}\n\n```{.r .cell-code}\nfplot <- function(shift) {\n  gasket <- ApollonianGasket(c0, n = 3, phi = 0.3, shift = shift, depth)\n  par(mar = c(0, 0, 0, 0))\n  plot(NULL,\n    type = \"n\", xlim = xlim, ylim = ylim,\n    xlab = NA, ylab = NA, axes = FALSE, asp = 1\n  )\n  draw(c0, border = \"black\", lwd = 2)\n  for (i in 1:depth) {\n    for (circ in gasket[[i]]) {\n      draw(circ, col = colors[i])\n    }\n  }\n}\n\nfanim <- function() {\n  shifts <- seq(0, 3, length.out = 101)[-101]\n  for (shift in shifts) {\n    fplot(shift)\n  }\n}\n\nlibrary(gifski)\nsave_gif(\n  fanim(),\n  \"ApollonianGasket.gif\",\n  width = 512, height = 512,\n  delay = 0.1\n)\n```\n:::\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/ApollonianGasket_compressed.gif){width=50%}\n\nWe can also animate the Apollonian gasket with the help of a Möbius \ntransformation. Consider the following complex matrix:\n\n$$\nM = \\begin{pmatrix}\ni & \\gamma \\\\\n\\bar\\gamma & -i\n\\end{pmatrix}\n$$\nwith $|\\gamma| < 1$. \n\nThe Möbius transformation associated to $M$ maps the unit disk to the unit disk \nand it is of order $2$. Its powers map the unit disk to the unit dis as well. \nBy the way, after some calculus, one can give the expression of $M^t$. \nWe find\n\n::: {.cell}\n\n```{.r .cell-code}\nMt <- function(gamma, t) {\n  h <- sqrt(1 - Mod(gamma)^2)\n  d2 <- h^t * (cos(t * pi / 2) + 1i * sin(t * pi / 2))\n  d1 <- Conj(d2)\n  A11 <- Re(d1) - 1i * Im(d1) / h\n  A12 <- Im(d2) * gamma / h\n  rbind(\n    c(A11, A12),\n    c(Conj(A11), Conj(A12))\n  )\n}\n```\n:::\n\nNow let's do the animation.\n\n::: {.cell}\n\n```{.r .cell-code}\nc0 <- Circle$new(c(0, 0), 1) # the exterior circle\ndepth <- 5\nApollonianCircles <- ApollonianGasket(c0, n = 3, phi = 0.1, shift = 0.5, depth)\nxlim <- c(-1.1, 1.1)\nylim <- c(-1.1, 1.1)\nopar <- par(mar = c(0, 0, 0, 0))\nfplot <- function(gamma, t) {\n  plot(NULL,\n    type = \"n\", xlim = xlim, ylim = ylim,\n    xlab = NA, ylab = NA, axes = FALSE, asp = 1\n  )\n  draw(c0, border = \"black\", lwd = 2)\n  Mob <- Mt(gamma, t)\n  for (i in 1:depth) {\n    for (circ in ApollonianCircles[[i]]) {\n      draw(Mob$transformCircle(circ), col = colors[i])\n    }\n  }\n}\nfanim <- function() {\n  gamma <- 0.5 + 0.4i\n  t_ <- seq(0, 2, length.out = 91)[-91]\n  for (t in t_) {\n    fplot(gamma, t)\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gifski)\nsave_gif(\n  fanim(),\n  \"ApollonianMobius.gif\",\n  width = 512, height = 512,\n  delay = 0.1\n)\npar(opar)\n```\n:::\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/ApollonianMobius.gif){width=60%}\n\n\n# Another Apollonian fractal\n\nLet's do another Apollonian fractal which uses the inner Soddy circle. \nAs you can see, the code is short:\n\n::: {.cell}\n\n```{.r .cell-code}\napollony <- function(c1, c2, c3, n) {\n  soddycircle <- soddyCircle(c1, c2, c3)\n  if (n == 1) {\n    soddycircle\n  } else {\n    c(\n      apollony(c1, c2, soddycircle, n - 1),\n      apollony(c1, soddycircle, c3, n - 1),\n      apollony(soddycircle, c2, c3, n - 1)\n    )\n  }\n}\n\nfractal <- function(n) {\n  c1 <- Circle$new(c(1, -1 / sqrt(3)), 1)\n  c2 <- Circle$new(c(-1, -1 / sqrt(3)), 1)\n  c3 <- Circle$new(c(0, sqrt(3) - 1 / sqrt(3)), 1)\n  do.call(c, lapply(1:n, function(i) apollony(c1, c2, c3, i)))\n}\n\ncircs <- fractal(4)\n```\n:::\n\nLet's plot the fractal in 3D with the help of the **rgl** package.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgl)\n# the spheres in rgl, obtained with the `spheres3d` function, are not smooth;\n# the way we use below provides pretty spheres\nunitSphere <- subdivision3d(icosahedron3d(), depth = 4L)\nunitSphere$vb[4L, ] <-\n  apply(unitSphere$vb[1L:3L, ], 2L, function(x) sqrt(sum(x * x)))\nunitSphere$normals <- unitSphere$vb\ndrawSphere <- function(circle, ...) {\n  center <- circle$center\n  radius <- abs(circle$radius)\n  sphere <- scale3d(unitSphere, radius, radius, radius)\n  shade3d(translate3d(sphere, center[1L], center[2L], 0), ...)\n}\n```\n:::\n\nNow here is how to plot the fractal and make an animation:\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot ####\nopen3d(windowRect = c(50, 50, 562, 562))\nbg3d(color = \"#363940\")\nview3d(35, 60, zoom = 0.95)\nfor (circ in circs) {\n  drawSphere(circ, color = \"darkred\")\n}\n# animation ####\nmovie3d(\n  spin3d(axis = c(0, 0, 1), rpm = 15),\n  duration = 4, fps = 15,\n  movie = \"Apollony\", dir = \".\",\n  convert = \"magick convert -dispose previous -loop 0 -delay 1x%d %s*.png %s.%s\",\n  startTime = 1 / 60\n)\n```\n:::\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/Apollony_compressed.gif){width=40%}\n\n\n# Malfatti gasket\n\nNow we will do something a bit more complicated. We will take a triangle, fill \neach of its three Malfatti circles with an Apollonian gasket, and fill the \nrest of the triangle with tangent circles. In fact, tangent spheres: we will \ndraw the result in 3D, this will be more pretty.\n\n::: {.cell}\n\n```{.r .cell-code}\ntoCplx <- function(M) {\n  M[1L] + 1i * M[2L]\n}\nfromCplx <- function(z) {\n  c(Re(z), Im(z))\n}\n\ndistance <- function(A, B) {\n  sqrt(c(crossprod(B - A)))\n}\n\ninnerSoddyRadius <- function(r1, r2, r3) {\n  1 / (1 / r1 + 1 / r2 + 1 / r3 + 2 * sqrt(1 / r1 / r2 + 1 / r2 / r3 + 1 / r3 / r1))\n}\n\ninnerSoddyCircle <- function(c1, c2, c3, ...) {\n  radius <- innerSoddyRadius(c1$radius, c3$radius, c3$radius)\n  center <- Triangle$new(c1$center, c2$center, c3$center)$equalDetourPoint()\n  c123 <- Circle$new(center, radius)\n  drawSphere(c123, ...)\n  list(\n    list(type = \"ccc\", c1 = c123, c2 = c1, c3 = c2),\n    list(type = \"ccc\", c1 = c123, c2 = c2, c3 = c3),\n    list(type = \"ccc\", c1 = c123, c2 = c1, c3 = c3)\n  )\n}\n\nside.circle.circle <- function(A, B, cA, cB, ...) {\n  if (A[2L] > B[2L]) {\n    return(side.circle.circle(B, A, cB, cA, ...))\n  }\n  rA <- cA$radius\n  rB <- cB$radius\n  zoA <- toCplx(cA$center)\n  zoB <- toCplx(cB$center)\n  zB <- toCplx(A)\n  alpha <- acos((B[1L] - A[1L]) / distance(A, B))\n  zX1 <- exp(-1i * alpha) * (zoA - zB)\n  zX2 <- exp(-1i * alpha) * (zoB - zB)\n  soddyR <- innerSoddyRadius(rA, rB, Inf)\n  if (Re(zX1) < Re(zX2)) {\n    Y <- (2 * rA * sqrt(rB) / (sqrt(rA) + sqrt(rB)) + Re(zX1)) +\n      sign(Im(zX1)) * 1i * soddyR\n  } else {\n    Y <- (2 * rB * sqrt(rA) / (sqrt(rA) + sqrt(rB)) + Re(zX2)) +\n      sign(Im(zX1)) * 1i * soddyR\n  }\n  M <- fromCplx(Y * exp(1i * alpha) + zB)\n  cAB <- Circle$new(M, soddyR)\n  drawSphere(cAB, ...)\n  list(\n    list(type = \"ccc\", c1 = cAB, c2 = cA, c3 = cB),\n    list(type = \"ccl\", cA = cA, cB = cAB, A = A, B = B),\n    list(type = \"ccl\", cA = cAB, cB = cB, A = A, B = B)\n  )\n}\n\nside.side.circle <- function(A, B, C, circle, ...) {\n  zA <- toCplx(A)\n  zO <- toCplx(circle$center)\n  vec <- zA - zO\n  P <- fromCplx(zO + circle$radius * vec / Mod(vec))\n  OP <- P - circle$center\n  onTangent <- P + c(-OP[2L], OP[1L])\n  L1 <- Line$new(P, onTangent)\n  P1 <- intersectionLineLine(L1, Line$new(A, C))\n  P2 <- intersectionLineLine(L1, Line$new(A, B))\n  incircle <- Triangle$new(A, P1, P2)$incircle()\n  drawSphere(incircle, ...)\n  list(\n    list(type = \"cll\", A = A, B = B, C = C, circle = incircle),\n    list(type = \"ccl\", cA = circle, cB = incircle, A = A, B = B),\n    list(type = \"ccl\", cA = circle, cB = incircle, A = A, B = C)\n  )\n}\n\nNewholes <- function(holes, color) {\n  newholes <- list()\n  for (i in 1L:3L) {\n    hole <- holes[[i]]\n    holeType <- hole[[\"type\"]]\n    if (holeType == \"ccc\") {\n      x <- with(hole, innerSoddyCircle(c1, c2, c3, color = color))\n    } else if (holeType == \"ccl\") {\n      x <- with(hole, side.circle.circle(A, B, cA, cB, color = color))\n    } else if (holeType == \"cll\") {\n      x <- with(hole, side.side.circle(A, B, C, circle, color = color))\n    }\n    newholes <- c(newholes, list(x))\n  }\n  newholes\n}\n\nMalfattiCircles <- function(A, B, C) {\n  Triangle$new(A, B, C)$MalfattiCircles()\n}\n\ndrawTriangularGasket <- function(mcircles, A, B, C, colors, depth) {\n  C1 <- mcircles[[1L]]\n  C2 <- mcircles[[2L]]\n  C3 <- mcircles[[3L]]\n  triangles3d(cbind(rbind(A, B, C), 0), col = \"yellow\", alpha = 0.2)\n  holes <- list(\n    side.circle.circle(A, B, C1, C2, color = colors[1L]),\n    side.circle.circle(B, C, C2, C3, color = colors[1L]),\n    side.circle.circle(C, A, C3, C1, color = colors[1L]),\n    innerSoddyCircle(C1, C2, C3, color = colors[1L]),\n    side.side.circle(A, B, C, C1, color = colors[1L]),\n    side.side.circle(B, A, C, C2, color = colors[1L]),\n    side.side.circle(C, A, B, C3, color = colors[1L])\n  )\n  for (d in 1L:depth) {\n    n_holes <- length(holes)\n    Holes <- list()\n    for (i in 1L:n_holes) {\n      Holes <- append(Holes, Newholes(holes[[i]], colors[d + 1L]))\n    }\n    holes <- do.call(list, Holes)\n  }\n}\n\ndrawCircularGasket <- function(c0, n, phi, shift, depth, colors) {\n  ApollonianCircles <- ApollonianGasket(c0, n, phi, shift, depth)\n  for (i in 1:depth) {\n    for (circ in ApollonianCircles[[i]]) {\n      drawSphere(circ, color = colors[i])\n    }\n  }\n}\n\nlibrary(viridisLite)\nA <- c(-5, -4)\nB <- c(5, -2)\nC <- c(0, 6)\nmcircles <- MalfattiCircles(A, B, C)\ndepth <- 3L\ncolors <- viridis(depth + 1L)\nn1 <- 3L\nn2 <- 4L\nn3 <- 5L\ndepth2 <- 3L\nphi1 <- 0.2\nphi2 <- 0.3\nphi3 <- 0.4\nshift <- 0\ncolors2 <- plasma(depth2)\n```\n:::\n\nAnd we get the 3D picture:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgl)\nopen3d(windowRect = c(50, 50, 562, 562), zoom = 0.9)\nbg3d(rgb(54, 57, 64, maxColorValue = 255))\ndrawTriangularGasket(mcircles, A, B, C, colors, depth)\ndrawCircularGasket(mcircles[[1L]], n1, phi1, shift, depth2, colors2)\ndrawCircularGasket(mcircles[[2L]], n2, phi2, shift, depth2, colors2)\ndrawCircularGasket(mcircles[[3L]], n3, phi3, shift, depth2, colors2)\n```\n:::\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/MalfattiGasket.png){width=50%}\n\nAs an exercise, you can add some animation to this picture, by animating the \nthree circular gaskets.\n\n\n# Circular Malfatti gasket\n\nYet another Malfatti based Apollonian gasket. This one uses the outer \nSoddy circle, which has a negative radius!\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgl)\n\niteration <- function(circlesWithIndicator, inversions) {\n  out <- list()\n  for (j in seq_along(circlesWithIndicator)) {\n    circle <- circlesWithIndicator[[j]][[\"circle\"]]\n    indic <- circlesWithIndicator[[j]][[\"indic\"]]\n    for (i in 1L:4L) {\n      if (i != indic) {\n        circleWithIndicator <- list(\n          \"circle\" = inversions[[i]]$invertCircle(circle),\n          \"indic\"  = i\n        )\n        out <- append(out, list(circleWithIndicator))\n      }\n    }\n  }\n  out\n}\n\ngasket <- function(circlesWithIndicator, inversions, depth, colors) {\n  if (depth > 0) {\n    circlesWithIndicator <- iteration(circlesWithIndicator, inversions)\n    for (i in seq_along(circlesWithIndicator)) {\n      drawSphere(circlesWithIndicator[[i]]$circle, color = colors[1L])\n    }\n    colors <- colors[-1L]\n    gasket(circlesWithIndicator, inversions, depth - 1L, colors)\n  }\n}\n\ndrawGasket <- function(triangle, depth, colors) {\n  Mcircles <- triangle$MalfattiCircles()\n  Mtriangle <- Triangle$new(\n    Mcircles[[1L]]$center, Mcircles[[2L]]$center, Mcircles[[3L]]$center\n  )\n  soddyO <- Mtriangle$outerSoddyCircle()\n  Mcircles <- append(Mcircles, list(soddyO))\n  for (i in 1L:4L) {\n    lines3d(\n      cbind(Mcircles[[i]]$asEllipse()$path(), 0),\n      color = \"black\", lwd = 2\n    )\n  }\n  inversions <- vector(\"list\", 4L)\n  circlesWithIndicator <- vector(\"list\", 4L)\n  inversions[[1L]] <- inversionFixingThreeCircles(\n    soddyO, Mcircles[[2L]], Mcircles[[3L]]\n  )\n  inversions[[2L]] <- inversionFixingThreeCircles(\n    soddyO, Mcircles[[1L]], Mcircles[[3L]]\n  )\n  inversions[[3L]] <- inversionFixingThreeCircles(\n    soddyO, Mcircles[[1L]], Mcircles[[2L]]\n  )\n  inversions[[4L]] <- inversionFixingThreeCircles(\n    Mcircles[[1L]], Mcircles[[2L]], Mcircles[[3L]]\n  )\n  for (i in 1L:4L) {\n    circlesWithIndicator[[i]] <-\n      list(\"circle\" = inversions[[i]]$invertCircle(Mcircles[[i]]), \"indic\" = i)\n    drawSphere(circlesWithIndicator[[i]]$circle, color = colors[1L])\n  }\n  colors <- colors[-1L]\n  gasket(circlesWithIndicator, inversions, depth, colors)\n}\n\nCircularMalfattiGasket <- function(C, depth, colors) {\n  A <- c(0, 0)\n  B <- c(1, 0)\n  t <- Triangle$new(A, B, C)\n  Mcircles <- t$MalfattiCircles()\n  Mtriangle <- Triangle$new(\n    Mcircles[[1L]]$center, Mcircles[[2L]]$center, Mcircles[[3L]]$center\n  )\n  soddyO <- Mtriangle$outerSoddyCircle()\n  center <- soddyO$center\n  radius <- -soddyO$radius\n  A1 <- (A - center) / radius\n  B1 <- (B - center) / radius\n  C1 <- (C - center) / radius\n  t1 <- Triangle$new(A1, B1, C1)\n  drawGasket(t1, depth, colors)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nopen3d(windowRect = 50 + c(0, 0, 900, 300))\nmfrow3d(1, 3)\nview3d(0, 0, zoom = 0.7)\nCircularMalfattiGasket(\n  C = c(0, sqrt(3 / 2)), depth = 2L,\n  colors = c(\"yellow\", \"orangered\", \"darkmagenta\")\n)\nnext3d()\nview3d(0, 0, zoom = 0.7)\nCircularMalfattiGasket(\n  C = c(1, sqrt(3 / 2)), depth = 2L,\n  colors = c(\"yellow\", \"orangered\", \"darkmagenta\")\n)\nnext3d()\nview3d(0, 0, zoom = 0.7)\nCircularMalfattiGasket(\n  C = c(2, sqrt(3 / 2)), depth = 2L,\n  colors = c(\"yellow\", \"orangered\", \"darkmagenta\")\n)\n```\n:::\n\n\n![](https://github.com/stla/PlaneGeometry/raw/master/inst/imgs/MalfattiCircularGasket.png){width=80%}\n\n\n# Hyperbola\n\nFinally, in order to illustrate the `Hyperbola` objects, we will check the \nso-called \"triangle tangent-asymptotes\" theorem. Observe the figure below. \nThe point `P` has been taken arbitrarily on the hyperbola, and the blue line \nis the tangent at `P`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# take a hyperbola\nL1 <- LineFromInterceptAndSlope(0, 2) # asymptote 1\nL2 <- LineFromInterceptAndSlope(-2, -0.15) # asymptote 2\nM <- c(2, 3) # a point on the hyperbola\nhyperbola <- Hyperbola$new(L1, L2, M)\n# take a point on the hyperbola and the tangent at this point\nOAB <- hyperbola$OAB()\nO <- OAB$O\nA <- OAB$A\nB <- OAB$B\nt <- 0.1\nP <- O + cosh(t) * A + sinh(t) * B\ntgt <- Line$new(P, P + sinh(t) * A + cosh(t) * B)\n# the triangle of interest\nC <- intersectionLineLine(L1, tgt)\nD <- intersectionLineLine(L2, tgt)\ntrgl <- Triangle$new(O, C, D)\n# plot\nopar <- par(mar = c(4, 4, 1, 1))\nhyperbola$plot(lwd = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.321808  2.115402 -2.688831  0.892157\n```\n\n\n:::\n\n```{.r .cell-code}\ndraw(L1, col = \"red\")\ndraw(L2, col = \"red\")\ntext(t(O), \"O\", pos = 3)\npoints(t(P), pch = 19, col = \"blue\")\ntext(t(P), \"P\", pos = 4)\ndraw(tgt, col = \"blue\", lwd = 2)\ntext(t(C), \"C\", pos = 2)\ntext(t(D), \"D\", pos = 4)\ntrgl$plot(add = TRUE, col = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hyperbola-1.png){width=2100}\n:::\n\n```{.r .cell-code}\npar(opar)\n# theorem checking: area of the triangle does not depend on\n# the choice of P; more precisely, it is equal to ab\ntrgl$area()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.930233\n```\n\n\n:::\n\n```{.r .cell-code}\nwith(hyperbola$abce(), a * b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.930233\n```\n\n\n:::\n:::\n\nThe theorem claims that the area of the yellow triangle does not depend on the \nlocation of `P`, and this area is equal to the product of the two semi-axes of \nthe hyperbola.\n\n## References\n\n1. Mark Liu.(2015). Non-Euclidean Pattern Making. <https://www.drmarkliu.com/noneuclidean>\n\n\n1. <https://fablab.ruc.dk/interactive-maps/>\n\n1. <https://fablab.ruc.dk/tag/learn/>\n\n1. Projection Mapping Library for p5.js. <https://github.com/jdeboi/p5.mapper>\n\n1. David Bouchard's (Java) Processing Keystone Library. <http://keystonep5.sourceforge.net/>\n\n1. Jenny Louthan, projection transform algorithms. <https://github.com/jlouthan/perspective-transform>\n\n1. p5.js + OSC protocol. <https://github.com/genekogan/p5js-osc>\n\n\n### Additional Readings\n\n1. Cracked: 6 TV Shows That Put Insane Work Into Details Nobody Noticed. <https://www.cracked.com/article_21544_6-tv-shows-that-put-insane-work-into-details-nobody-noticed.html>\n\n1. Mark Liu. (2016). *Why STEM subjects and fashion design go hand in hand*. <https://theconversation.com/why-stem-subjects-and-fashion-design-go-hand-in-hand-63649>\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}