{
  "hash": "92983996a27be84f93c135ab30fd1810",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 23/Nov/2024\ndate-modified: \"2025-04-26\"\ntitle: \"The Multilayer Perceptron\"\norder: 30\nsummary: \ntags:\n- Neural Nets\n- Hidden Layers\nfilters:\n  - d2\nd2:\n  layout: elk\n  theme: \"CoolClassics\"\n  sketch: true\n---\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n## {{< iconify icons8 idea >}} What is a Multilayer Perceptron?\n\nThis was our bare bones Perceptron, or neuron as we will refer to it\nhenceforth:\n\n$$\ny_k = sign~(~\\sum_{k=1}^n W_k*x_k + b~)\n$$\n\n\n::: {.cell}\n\n```{.d2 .cell-code}\ndirection: right\ngrid-gap: 10\ntitle: The Perceptron {\n  shape: text\n  near: top-center\n  style: {\n    font-size: 30\n    italic: true\n  }\n}\nin1.style.opacity: 0\nin2.style.opacity: 0\nin3.style.opacity: 0\nin4.style.opacity: 0\nin5.style.opacity: 0\nin6.style.opacity: 0\n1.shape: circle\n2.shape: circle\n3.shape: circle\n4.shape: circle\n5.shape: circle\n6.shape: circle\nact.shape: circle\nact {\n  icon: ./carbon--chart-logistic-regression.svg\n}\nout.style.opacity: 0\n###\nin1 -> 1\nin2 -> 2\nin3 -> 3\nin4 -> 4\nin5 -> 5\nin6 -> 6\n\n1 -> act\n2 -> act\n3 -> act\n4 -> act\n5 -> act\n6 -> act\n\nact -> out\n\n```\n:::\n\n\n\nFor the multi-layer perceptron, two changes were made:\n\n- Changing the hard-threshold activation into a more soft sigmoid activation\n\n- addition of (one or more ) **hidden layers**.\n\nLet us discuss these changes in detail. \n\n#### What is the Activation Block?\n\n-   We said earlier that the weighting and adding is a linear operation.\n-   While this is great, simple linear translations of data are not\n    capable of generating what we might call learning or generalization\n    ability.\n-   The outout of the perceptron is a \"learning decision\" that is made by deciding if the combined output is greater or smaller than a ***threshold***. \n-   We need to have some non-linear block to allow the data to create\n    nonlinear transformations of the data space, such as *curving it, or\n    folding it, or creating bumps, depressions, twists*, and so on.\n\n![Activation](../../../../../materials/images/png/Activation_Functions.png){height=\"360\"}\n\n-   This nonlinear function needs to be chosen with care so that it is\n    both differentiable and keeps the math analysis tractable. (More\n    later)\n-   Such a nonlinear mathematical function is implemented in the\n    **Activation Block**.\n-   See this example: red and blue areas, which we wish to **separate\n    and classify these** with our DLNN, are not separable unless we fold\n    and curve our 2D data space.\n-   The separation is achieved using a linear operation, i.e. a LINE!!\n\n![From [Colah\nBlog](https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/img/spiral.1-2.2-2-2-2-2-2.gif),\nused sadly without\npermission](https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/img/spiral.1-2.2-2-2-2-2-2.gif){#fig-manifolds-and-neural-networks}\n\n-   For instance in @fig-manifolds-and-neural-networks, no amount of\n    stretching or compressing of the surface can separate the two sets (\n    blue and red ) using a line or plane, **unless** the surface can be\n    warped into **another dimension** by folding.\n    \n\n#### What is the Sigmoid Function?\n\nThe hard-threshold used in the [Perceptron](../20-Perceptron/index.qmd) allowed us to make certain decisions based on **linear combinations** of the input data. But what is the dataset possesses *classes* that are not separable in a linear way? What if different categories of points are intertwined with a curved boundary between classes?\n\nWe need to have some non-linear block to allow the data to create nonlinear transformations of the data space, such as *curving it, or folding it, or creating bumps, depressions, twists*, and so on. \n\n![Activation](../../../../../materials/images/png/Activation_Functions.png){height=\"360\"}\n\n-   This nonlinear function needs to be chosen with care so that it is\n    both differentiable and keeps the math analysis tractable. (More\n    later)\n-   Such a nonlinear mathematical function is implemented in the\n    **Activation Block**.\n-   See this example: red and blue areas, which we wish to **separate\n    and classify these** with our DLNN, are not separable unless we fold\n    and curve our 2D data space.\n-   The separation is achieved using a linear operation, i.e. a LINE!!\n\n![From [Colah\nBlog](https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/img/spiral.1-2.2-2-2-2-2-2.gif),\nused sadly without\npermission](https://colah.github.io/posts/2014-03-NN-Manifolds-Topology/img/spiral.1-2.2-2-2-2-2-2.gif){#fig-manifolds-and-neural-networks}\n\n-   For instance in @fig-manifolds-and-neural-networks, no amount of\n    stretching or compressing of the surface can separate the two sets (\n    blue and red ) using a line or plane, **unless** the surface can be\n    warped into **another dimension** by folding.\n\nSo how do we implement this nonlinear Activation Block?\n\n-   One of the popular functions used in the Activation Block is a\n    function based on the exponential function $e^x$.\n-   Why? Because this function retains is identity when differentiated!\n    This is a very convenient property!\n\n![Sigmoid\nActivation](../../../../../materials/images/png/Sigmoid.png){height=\"360\"}\n\n::: callout-note\n#### Remembering Logistic Regression\n\nRecall your study of [Logistic\nRegression](../../../../Analytics/Modelling/Modules/LogReg/index.qmd).\nThere, the Sigmoid function was used to model the odds of the\n(Qualitative) target variable against the (Quantitative) predictor.\n:::\n\n::: callout-note\n#### But Why Sigmoid?\n\nBecause [the Sigmoid function is\ndifferentiable](https://math.stackexchange.com/questions/78575/derivative-of-sigmoid-function-sigma-x-frac11e-x).\nAnd linear in the mid ranges. Oh, and remember the [Chain\nRule](https://en.wikipedia.org/wiki/Derivative#Rules_for_basic_functions)?\n\n$$\n\\begin{align}\n\\frac{df(x)}{dx}\n&= \\frac{d}{dx} * \\frac{1}{1 + e^{-x}} \\\\\\\n&= -(1 + e^{-x})^{-2} * \\frac{d}{dx}(1 + e^{-x})~~\\text{(Using Chain Rule)}\\\\\n&= -(1 + e^{-x})^{-2} * (-e^{-x})\\\\\n&=  \\frac{e^{-x}}{(1 + e^{-x})^{2}}\\\\\n&= \\frac{(1 + e^{-x}) -1}{(1 + e^{-x})^{2}}\\\\\n&= \\frac{1}{1 + e^{-x}} * \\Bigg({\\frac{1 + e^{-x}}{1 + e^{-x}}} - \\frac{1}{1 + e^{-x}}\\Bigg)\\\\\\\n&\\text{ and therefore}\\\\\\\n\\Large{\\frac{df(x)}{dx}} &= \\Large{f(x) * (1 - f(x))}\\\\\n\\end{align}\n$$\n:::\n\n\n#### What are Hidden Layers?\n\nThe MLP adds several layers of perceptrons, in **layers**, as shown below:\n\n\n::: {.cell}\n\n```{.d2 .cell-code}\ntitle: Multilayer Perceptron {\n  shape: text\n  near: top-center\n  style: {\n    font-size: 30\n    italic: true\n  }\n}\ndirection: right\ngrid-columns: 5\ngrid-rows: 3\n###\nin1: \"in1\" {shape: circle\n     style: {\n      font-size: 25\n      stroke: white\n      fill: white\n    }}\nin2: \"in2\" {shape: circle\n     style: {\n      font-size: 25\n      stroke: white\n      fill: white\n    }}\nin3: \"in3\" {shape: circle\n     style: {\n      font-size: 25\n      stroke: white\n      fill: white\n    }}\ni1: {shape: circle\n     style: {\n      font-size: 25\n      fill: white\n    }}\ni2: {shape: circle\n     style: {\n      font-size: 25\n      fill: white\n    }}\ni3: {shape: circle\n     style: {\n      font-size: 25\n      fill: white\n    }}\nh1: {shape: circle\n     style: {\n      stroke: blue\n      font-color: blue\n      font-size: 25\n      stroke-dash: 2\n      stroke-width: 6\n      fill: white\n    }}\nh2: {shape: circle\n     style: {\n      stroke: blue\n      font-color: blue\n      font-size: 25\n      stroke-dash: 2\n      stroke-width: 6\n      fill: white\n    }}\nh3: {shape: circle\n     style: {\n      stroke: blue\n      font-color: blue\n      font-size: 25\n      stroke-dash: 2\n      stroke-width: 6\n      fill: white\n    }}\no1: {shape: circle\n     style: {\n      font-size: 25\n      fill: white\n    }}\no2: {shape: circle\n     style: {\n      font-size: 25\n      fill: white\n    }}\no3: {shape: circle\n     style: {\n      font-size: 25\n      fill: white\n    }}\nout1: \"out1\" {shape: circle\n     style: {\n      font-size: 25\n      stroke: white\n      fill: white\n    }}\nout2: \"out2\" {shape: circle\n     style: {\n      font-size: 25\n      stroke: white\n      fill: white\n    }}\nout3: \"out3\" {shape: circle\n     style: {\n      font-size: 25\n      stroke: white\n      fill: white\n    }}\n###\nin1 -> i1\nin2 -> i2\nin3 -> i3\ni1 -> h1\ni1 -> h2\ni1 -> h3\ni2 -> h1\ni2 -> h2\ni2 -> h3\ni3 -> h1\ni3 -> h2\ni3 -> h3\nh1 -> o1\nh2 -> o1\nh3 -> o1\nh1 -> o2\nh2 -> o2\nh3 -> o2\nh1 -> o3\nh2 -> o3\nh3 -> o3\n\no1 -> out1\no2 -> out2\no3 -> out3\n\n```\n:::\n\n\n<br>\n\n-   Here, `i1`, `i2`, and `i3` are *input neurons*: they are simply\n    inputs and are drawn as circles in the literature.\n-   The `h1`, `h2`, `h3` are neuron in the so-called **hidden layer**;\n    *hidden* because they are not inputs!\n-   The neurons `o1`, `o2`, and `o3` are **output neurons**.\n-   The signals/information flows from left to right in the diagram. And\n    we have shown every neuron connected to everyone in the next layer\n    downstream.\n\nHow do we mathematically, and concisely, express the operation of the\nMLP? Let us setup a notation for the MLP weights.\n\n-   $l$ : layer index;\n-   $j$, $k$ : neuron index in two adjacent layers\n-   $W^l_{jk}$ (i.e. $W^{layer}_{{source}~{destn}}$) : weight from $j$th neuron / $(l−1)$th layer to $k$th\n    neuron / $l$th layer;\n-   $b^l_k$ : *bias* of the $k$th neuron in the $l$th layer.\n-   $a^l_k$ : activation (output) of $k$th neuron / $l$th layer.\n\n\n\n::: {.cell}\n\n```{.d2 .cell-code}\ntitle: Data Processing between Layers {\n  shape: text\n  near: top-center\n  style: {\n    font-size: 60\n    italic: true\n  }\n}\n\ndirection: right\ngrid-columns: 3\ngrid-gap: 400\n\nlayer-1: \"Layer-1 : Index(j)\" {\n  grid-columns: 1\n  grid-gap: 100\n  style: {\n      font-size: 30\n    }\n  1 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  2 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  3 {shape: circle\n     style: {\n      font-size: 45\n    }}\n}\nlayer-2: \"Layer-2 : Index(k)\" {\n  grid-columns: 1\n  grid-gap: 100\n  style: {\n      font-size: 30\n    }\n  h1 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  h2 {shape: circle\n     style: {\n      font-size: 45\n    }}\n  h3 {shape: circle\n     style: {\n      font-size: 45\n    }}\n}\n\nlayer-3: {\n  grid-columns: 1\n  grid-gap: 100\n  style: {\n    opacity: 0\n  }\n    a12: \"a12\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n    }}\n    a22: \"a22\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n    }}\n    a32: \"a32\" {shape: circle\n     style: {\n      font-size: 45\n      stroke: white\n      fill: white\n     }\n     }\n}\nlayer-1.1 -> layer-2.h1: W11 {\n  source-arrowhead.label: a11\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\nlayer-1.1 -> layer-2.h2 {style:{stroke: grey}}\nlayer-1.1 -> layer-2.h3 {style:{stroke: grey}}\nlayer-1.2 -> layer-2.h1: W21 {\n  source-arrowhead.label: a21\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\nlayer-1.2 -> layer-2.h2 {style:{stroke: grey}}\nlayer-1.2 -> layer-2.h3 {style:{stroke: grey}}\nlayer-1.3 -> layer-2.h1: W31 {\n  source-arrowhead.label: a31\n  style: {\n    font-size: 45\n    fill: LightBlue\n    stroke: FireBrick\n    stroke-width: 9\n    animated: true\n  }\n}\nlayer-1.3 -> layer-2.h2 {style:{stroke: grey}}\nlayer-1.3 -> layer-2.h3 {style:{stroke: grey}}\n\nlayer-2.h1 -> layer-3.a12 { style: {stroke-width: 9\n         stroke: FireBrick}}\nlayer-2.h2 -> layer-3.a22 {style:{stroke: grey}}\nlayer-2.h3 -> layer-3.a32 {style:{stroke: grey}}\n\n```\n:::\n\n\n\n<br> We can write the outputs of the `layer-2` as:\n\n$$\n\\begin{align}\n(k = 1): ~ a_{12} = sigmoid~(~\\color{red}{W^2_{11}*a_{11}} + \\color{skyblue}{W^2_{21}*a_{21}} + \\color{forestgreen}{W^2_{31}*a_{31}} ~ + b_{12})\\\\\n(k = 2): ~ a_{22} = sigmoid~(~W^2_{12}*a_{11} + W^2_{22}*a_{21} + W^2_{32}*a_{31}~ + b_{22} )\\\\\n(k = 3): ~ a_{32} = sigmoid~(~W^2_{13}*a_{11} + W^2_{23}*a_{21} + W^2_{33}*a_{31}~ + b_{32})\\\\\n\\end{align}\n$$ \n\nIn (dreaded?) matrix notation :\n\n$$\n\\begin{bmatrix}\na_{12}\\\\\na_{22}\\\\\na_{32}\\\\\n\\end{bmatrix} = \nsigmoid~\\Bigg(\n\\begin{bmatrix}\n\\color{red}{W^2_{11}} & \\color{skyblue}{W^2_{21}} & \\color{forestgreen}{W^2_{31}}\\\\\nW^2_{12} & W^2_{22} & W^2_{32}\\\\\nW^2_{13} & W^2_{23} & W^2_{33}\\\\\n\\end{bmatrix} * \n\\begin{bmatrix}\n\\color{red}{a_{11}}\\\\\n\\color{skyblue}{a_{21}}\\\\\n\\color{forestgreen}{a_{31}}\\\\\n\\end{bmatrix} +\n\\begin{bmatrix}\nb_{12}\\\\\nb_{22}\\\\\nb_{32}\\\\\n\\end{bmatrix}\n\\Bigg)\n$$ \n\n\nIn compact notation we write, in general:\n\n$$\nA^l = \\sigma\\Bigg(W^lA^{l-1} + B^l\\Bigg)\n$$\n\n\n\n$$\na^l_j=σ(\\sum_kW^l_{jk} * a^{l−1}_k+b^l_j)\n$$ {#eq-forward-prop}\n\n\n## {{< iconify mingcute thought-line >}} Wait, But Why?\n\n- The \"vanilla\" perceptron was big advance in AI and learning. However, it was realized that this can only make classification decisions with data that are [linearly separable](https://www.wikiwand.com/en/articles/Linear_separability).\n- Including a differentiable non-linearity in the activation block allows us to deform the coordinate space in which the data points are mapped.\n- This deformation may permit unique views of the data wherein the categories of data are separable by an n-dimensional plane. \n- This idea is also used in a machine learning algorithm called [Support Vector Machines.](../../../../ML4Artists/Modules/35-SVM/index.qmd)\n\n\n## MLPs in Code\n\n::: {.panel-tabset .nav-pills style=\"background: whitesmoke \"}\n### Using p5.js\n\n### Using R\n\nUsing `torch`.\n:::\n\n## References\n\n1.  Tariq Rashid. *Make your own Neural Network*. [PDF\n    Online](https://github.com/harshitkgupta/StudyMaterial/blob/master/Make%20Your%20Own%20Neural%20Network%20(Tariq%20Rashid)%20-%20%7BCHB%20Books%7D.pdf)\n1.  Mathoverflow. *Intuitive Crutches for Higher Dimensional Thinking*.\n    <https://mathoverflow.net/questions/25983/intuitive-crutches-for-higher-dimensional-thinking>\n1. 3D MatMul Visualizer<https://bhosmer.github.io/mm/ref.html>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}